This directory is used to generate assembly code that is then converted into Go's assembly.

The key is to use gcc's autovec functionality, generate a `.s` file, then use [c2goasm](https://github.com/minio/c2goasm) to actually generate Go assembly.

While it's ideal to automatically generate the stubs and all that as well (per c2goasm's use), it's perhaps better to actually manually renamed as the files are copied out to the outer directory.

## Requirements ##

You will need

1. YASMe
2. Some kind of optimizing compiler for C to generate `.s` files.
3. following Go packages

```
go get -u github.com/minio/asm2plan9s
go get -u github.com/minio/c2goasm
go get -u github.com/klauspost/asmfmt/cmd/asmflt
```

# Instructions #

1. Write the C file. Write a stub in Go.
2. Use a C compiler to compile to an `.s` file. Assembly must be in Intel format. Instructions for GCC and Clang are below.
3. Use `c2goasm` go generate a Go asm. `c2goasm -a -f RAWSUM_sse.s sum_go.s`
4. Inspect and update the function's calling convention to match.
5. Add the correct build tags.
6. Copy over to the outer directory. Rename the files to match the convention
7. Add tests and benchmarks

## Example ##

An example is shown - `Sum`.

The source code is in `sum.c`. The generated assembly is `sum.s`. The Go stub file is `sum_go.go`. The final output generated by `c2goasm` dictates the name of the stub file. In this case, I simply call it `sum_go.s`, so my stub file is called `sum_go.go`.

To necessitate the translation of C to Go, the stub models the function signature of the C code. e.g.

The C code's signature is `void sum(double a[], int len, double* retVal)`. The Go stub's signature is similar: `func __sum(a unsafe.Pointer, l int, retVal unsafe.Pointer)`

Two things to observe:

1. The Go function name has TWO underscores `__`. This is because gcc labels the assembly with `_sum` and then `c2goasm` adds an additional underscore, making it `__sum`. The stub function name must match. They may be changed later.
2. The stub function uses `unsafe`, and doesn't have a return value. This is perhaps the best way of dealing with things. Otherwise you would have to mess around with the calling conventions.

The diff between the final `.s` file and the assembly generated by `c2goasm` is as follows:

```
@@ -1,15 +1,11 @@
-//+build avx
-//+build amd64
 //+build !noasm !appengine
-
 // AUTO-GENERATED BY C2GOASM -- DO NOT EDIT

-// But clearlly edited by Chewxy to give it some customizations
-#include "textflag.h"
-TEXT ·sum(SB), NOSPLIT, $0
-	MOVQ a_data+0(FP), DI
-	MOVQ a_len+8(FP), SI
-	MOVQ retVal+24(FP), DX // c2goasm does retVal+16. But a slice is 3 words, so it's +24.
+TEXT ·__sum(SB), $0-24
+
+	MOVQ a+0(FP), DI
+	MOVQ l+8(FP), SI
+	MOVQ retVal+16(FP), DX

 	WORD $0xf685             // test    esi, esi
 	JLE  LBB0_1
@@ -82,7 +78,7 @@
 	JNE  LBB0_11

 LBB0_12:
-	LONG $0x0211fbc5         // vmovsd    qword [rdx], xmm0
+	LONG $0x0211fbc5 // vmovsd    qword [rdx], xmm0
 	VZEROUPPER
 	RET
```

## GCC instructions ##

For example, for AVX:

```
gcc -c -S -o OUTFILENAME.s -O3 -faggressive-loop-optimizations -funroll-loops -finline-functions -ftree-vectorize -ftree-loop-vectorize  -ffast-math -fno-rtti -fno-asynchronous-unwind-tables  -mavx -mtune=native -mvzeroupper -masm=intel -mno-red-zone FILENAME.c
```
